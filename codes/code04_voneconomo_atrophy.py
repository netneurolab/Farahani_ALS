"""
*******************************************************************************

Script purpose:

    Look into von-Economo classes and quantify atrophy values within each class.

Script output:

    -----------------------------------------------------------------------

    subtype = all
    nspin = 1,000 - thr = 0 ( include negative values ), method: vasa

    ----------------------------------------------------------------------

    measure value
    [ 0.11172739 0.00458125 0.00947419 -0.0258814 -0.04482701 0.00910162 -0.02808611]

    ----------------------------------------------------------------------

    corrected p vals
    [0.00699301 0.91308691 0.91308691 0.14219114 0.01048951 0.91308691 0.43006993]

    ----------------------------------------------------------------------

    uncorrected p vals
    [0.000999 0.91308691 0.87812188 0.06093906 0.002997 0.66633367 0.24575425]

    ----------------------------------------------------------------------

Note:

    The results are provided in Fig. 1d.

*******************************************************************************
"""

#------------------------------------------------------------------------------
# Libraries
#------------------------------------------------------------------------------

import os
import scipy.io
import numpy as np
import matplotlib.pyplot as plt
from neuromaps.images import load_data
from neuromaps.images import dlabel_to_gifti
from netneurotools import datasets as nntdata
from nilearn.datasets import fetch_atlas_schaefer_2018
from statsmodels.stats.multitest import multipletests
from functions import (parcel2fsLR,
                       save_gifti,
                       pval_cal,
                       vasa_null_Schaefer)
from globals import path_results, path_fig, nnodes, path_atlas, path_surface, path_wb_command

#------------------------------------------------------------------------------
# Constants
#------------------------------------------------------------------------------

subtype = 'all' # Options: 'all', 'spinal', 'bulbar'
nspins  = 1000  # number of null realizations for the spin test

#------------------------------------------------------------------------------
# Load group-averegd parcellated w-score data ( generated by code3 )
#------------------------------------------------------------------------------

disease_profile = np.load(path_results + 'mean_w_score_' + subtype + '_Schaefer.npy')

#------------------------------------------------------------------------------
# Load von-economo atlas information
#------------------------------------------------------------------------------

def load_von_economo_atlas(path_in, nnodes):
    atlas_data = np.squeeze(scipy.io.loadmat(path_in + 'economo_Schaefer400.mat')['pdata'])
    return atlas_data - 1, ['primary motor',
                            'association',
                            'association',
                            'primary/secondary sensory',
                            'primary sensory',
                            'limbic',
                            'insular']

atlas_7Network_von, label_von_networks = load_von_economo_atlas(path_atlas, nnodes)
num_labels = len(label_von_networks)

#------------------------------------------------------------------------------
# Save atlas border files on fsLR for later visualization in workbench
# start -----------------------------------------------------------------------

schaefer = nntdata.fetch_schaefer2018('fslr32k')['400Parcels7Networks']
atlas = load_data(dlabel_to_gifti(schaefer))

save_gifti(parcel2fsLR(atlas,
                       1 + atlas_7Network_von[:int(nnodes/2)].reshape(int(nnodes/2), 1),
                       'L'), 
           path_results + 'lh.vonEconomo')
save_gifti(parcel2fsLR(atlas,
                       1 + atlas_7Network_von[int(nnodes/2):].reshape(int(nnodes/2), 1),
                       'R'), 
           path_results + 'rh.vonEconomo')

command = f'{path_wb_command} -metric-label-import ' + \
          f'{os.path.join(path_results, "lh.vonEconomo.func.gii")} ' + \
          f'{os.path.join(path_results, "black.txt")} ' + \
          f'{os.path.join(path_results, "lh.vonEconomo.label.gii")}'
os.system(command)
command = f'{path_wb_command} -metric-label-import ' + \
          f'{os.path.join(path_results, "rh.vonEconomo.func.gii")} ' + \
          f'{os.path.join(path_results, "black.txt")} ' + \
          f'{os.path.join(path_results, "rh.vonEconomo.label.gii")}'
os.system(command)

# generate border for primary motor cortex defined by the von-economo atlas
command = f'{path_wb_command} -label-to-border ' + \
          f'{os.path.join(path_surface, "S1200.L.inflated_MSMAll.32k_fs_LR.surf.gii")} ' +\
          f'{os.path.join(path_results, "lh.vonEconomo.label.gii")} ' +\
          f'{os.path.join(path_results, "lh.vonEconomo.border")}'
os.system(command)
command = f'{path_wb_command} -label-to-border ' + \
          f'{os.path.join(path_surface, "S1200.R.inflated_MSMAll.32k_fs_LR.surf.gii")} ' +\
          f'{os.path.join(path_results, "rh.vonEconomo.label.gii")} ' +\
          f'{os.path.join(path_results, "rh.vonEconomo.border")}'
os.system(command)

# end -------------------------------------------------------------------------

#------------------------------------------------------------------------------
# Needed information to do spin-test
#------------------------------------------------------------------------------

schaefer = fetch_atlas_schaefer_2018(n_rois = nnodes)
spins = vasa_null_Schaefer(nspins)

#------------------------------------------------------------------------------
# Von-Economo atlas results
#------------------------------------------------------------------------------

# Get actual/real values
network_specific_disease_measure = np.zeros((num_labels,))
for label_ind in range(num_labels):
    temp = []
    for roi_ind in range(nnodes):
        if atlas_7Network_von[roi_ind] == label_ind:
            temp.append(disease_profile[roi_ind,])
    print(np.array(temp).shape)
    network_specific_disease_measure[label_ind,] = np.nanmean(np.array(temp))

# Get null values
network_specific_disease_measure_nulls = np.zeros((num_labels, nspins))
for spin_ind in range(nspins):
    spinned_disease_measure = disease_profile[spins[:, spin_ind]]
    for label_ind in range(num_labels):
        temp = []
        for roi_ind in range(nnodes):
            if atlas_7Network_von[roi_ind] == label_ind:
                temp.append(spinned_disease_measure[roi_ind])
        network_specific_disease_measure_nulls[label_ind, spin_ind] = np.nanmean(np.array(temp))

# Get non-parametric p-value given the null distributions
p_value_spin = np.zeros((num_labels,))
for label_ind in range(num_labels):
    p_value_spin[label_ind] = pval_cal(network_specific_disease_measure[label_ind],
                                       network_specific_disease_measure_nulls[label_ind, :].flatten(),
                                       nspins)

# Perfrom FDR correction
p_value_spin_fdr = multipletests(p_value_spin, method = 'fdr_bh')[1]

#------------------------------------------------------------------------------
# Print some results
#------------------------------------------------------------------------------

print('----------------------------------------------------------------------')
print('measure value')
print(network_specific_disease_measure)
print('----------------------------------------------------------------------')
print('corrected p vals')
print(p_value_spin_fdr)
print('----------------------------------------------------------------------')
print('uncorrected p vals')
print(p_value_spin)
print('----------------------------------------------------------------------')

#------------------------------------------------------------------------------
# Visualization of the results as a barplot - Fig. 1d.
#------------------------------------------------------------------------------

bar_width = 0.75
y = np.arange(len(label_von_networks))

fig, ax = plt.subplots(figsize = (5, 2))

for i, height in enumerate(network_specific_disease_measure):
    ax.barh(y[i], height, height = bar_width, color = 'silver', alpha = 1)

ax.set_yticks(y)
ax.set_yticklabels(label_von_networks)
ax.spines['top'].set_visible(False)
ax.spines['right'].set_visible(False)
ax = plt.gca()

# Generate x-axis ticks including the maximum value
x_ticks = np.linspace(-0.05, 0.12, num = 5) # 5 ticks from 0 to x_max
ax.set_xticks(x_ticks)
plt.tight_layout()
plt.savefig(os.path.join(path_fig, 'von_economo_classes_' + subtype + '.svg'),
            bbox_inches = 'tight',
            dpi = 300,
            transparent = True)
plt.show()

#------------------------------------------------------------------------------
# END