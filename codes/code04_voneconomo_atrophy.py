"""
*******************************************************************************

Purpose:
    Look into von-Economo classes and quantify atrophy values

Results:

    nspin = 1,000 - thr = 0 ( include negative values ), method: vasa
    ----------------------------------------------------------------------
    measure value
    [ 0.11172739  0.00458125  0.00947419 -0.0258814  -0.04482701  0.00910162
     -0.02808611]
    ----------------------------------------------------------------------
    corrected p vals
    [0.00699301 0.91308691 0.91308691 0.14219114 0.01048951 0.91308691
     0.43006993]
    ----------------------------------------------------------------------
    uncorrected p vals
    [0.000999   0.91308691 0.87812188 0.06093906 0.002997   0.66633367
     0.24575425]
    ----------------------------------------------------------------------

    nspin = 1,000 - thr = 0 ( include negative values ), method: original
    ----------------------------------------------------------------------
    measure value
    [ 0.11172739  0.00458125  0.00947419 -0.0258814  -0.04482701  0.00910162
     -0.02808611]
    ----------------------------------------------------------------------
    corrected p vals
    [0.00699301 0.55384615 0.62237762 0.55710956 0.48601399 0.55384615
     0.55384615]
    ----------------------------------------------------------------------
    uncorrected p vals
    [0.000999   0.3956044  0.62237762 0.47752248 0.13886114 0.26273726
     0.36463536]
    ----------------------------------------------------------------------
*******************************************************************************
"""

#------------------------------------------------------------------------------
# Libraries
#------------------------------------------------------------------------------

import os
import warnings
import scipy.io
import numpy as np
import matplotlib.pyplot as plt
from IPython import get_ipython
from neuromaps.images import load_data
from neuromaps.images import dlabel_to_gifti
from netneurotools import datasets as nntdata
from netneurotools.stats import gen_spinsamples
from nilearn.datasets import fetch_atlas_schaefer_2018
from statsmodels.stats.multitest import multipletests
from functions import (parcel2fsLR,
                       save_gifti,
                       pval_cal)

#------------------------------------------------------------------------------
# Configuration
#------------------------------------------------------------------------------

warnings.filterwarnings("ignore")
get_ipython().magic('reset -sf')

#------------------------------------------------------------------------------
# Paths
#------------------------------------------------------------------------------

base_path    = '/Users/asaborzabadifarahani/Desktop/ALS/ALS_git/'
path_results = os.path.join(base_path,'results/')
script_name  = os.path.basename(__file__).split('.')[0]
path_fig     = os.path.join(os.getcwd(), 'generated_figures/', script_name)
os.makedirs(path_fig, exist_ok = True)

#------------------------------------------------------------------------------
# Constants
#------------------------------------------------------------------------------

nnodes  = 400
subtype = 'all'
thr     = 0     # Include negative values of w-score or not
nspins  = 1000 # number of null realizations for the spin test

#------------------------------------------------------------------------------
# Load group-averegd parcellated w-score data ( generated by code3 )
#------------------------------------------------------------------------------

disease_profile = np.load(path_results + 'mean_w_score_' + subtype + '_schaefer.npy')

if thr == 1:
    disease_profile[disease_profile <= 0] = 0

#------------------------------------------------------------------------------
# Load von-economo atlas information
#------------------------------------------------------------------------------

def load_von_economo_atlas(base_path, nnodes):
    atlas_data = np.squeeze(scipy.io.loadmat(base_path + 'data/economo_Schaefer400.mat')['pdata'])
    return atlas_data - 1, ['primary motor',
                            'association',
                            'association',
                            'primary/secondary sensory',
                            'primary sensory',
                            'limbic',
                            'insular']

atlas_7Network_von, label_von_networks = load_von_economo_atlas(base_path, nnodes)
num_labels = len(label_von_networks)

#------------------------------------------------------------------------------
# Save atlas surface files on fsLR for later visualization in workbench
# start -----------------------------------------------------------------------

schaefer = nntdata.fetch_schaefer2018('fslr32k')['400Parcels7Networks']
atlas = load_data(dlabel_to_gifti(schaefer))

save_gifti(parcel2fsLR(atlas,
                       1 + atlas_7Network_von[:int(nnodes/2)].reshape(int(nnodes/2), 1),
                       'L'), 
           path_results + 'lh.vonEconomo')
save_gifti(parcel2fsLR(atlas,
                       1 + atlas_7Network_von[int(nnodes/2):].reshape(int(nnodes/2), 1),
                       'R'), 
           path_results + 'rh.vonEconomo')

path_wb_command = '/Users/asaborzabadifarahani/Downloads/workbench/bin_macosx64/wb_command'
command = f'{path_wb_command} -metric-label-import ' + \
          f'{os.path.join(path_results, "lh.vonEconomo.func.gii")} ' + \
          f'{os.path.join(path_results, "text_voneconomo.txt")} ' + \
          f'{os.path.join(path_results, "lh.vonEconomo.label.gii")}'
os.system(command)

path_wb_command = '/Users/asaborzabadifarahani/Downloads/workbench/bin_macosx64/wb_command'
command = f'{path_wb_command} -metric-label-import ' + \
          f'{os.path.join(path_results, "rh.vonEconomo.func.gii")} ' + \
          f'{os.path.join(path_results, "text_voneconomo.txt")} ' + \
          f'{os.path.join(path_results, "rh.vonEconomo.label.gii")}'
os.system(command)

# generate border for primary motor cortex defined by the von-economo atlas
path_surface = '/Users/asaborzabadifarahani/Desktop/GA/HumanCorticalParcellations_wN_6V6gD/'
command = f'{path_wb_command} -label-to-border ' + \
          f'{os.path.join(path_surface, "S1200.L.inflated_MSMAll.32k_fs_LR.surf.gii")} ' +\
          f'{os.path.join(path_results, "lh.vonEconomo.label.gii")} ' +\
          f'{os.path.join(path_results, "lh.vonEconomo.border")}'
os.system(command)

command = f'{path_wb_command} -label-to-border ' + \
          f'{os.path.join(path_surface, "S1200.R.inflated_MSMAll.32k_fs_LR.surf.gii")} ' +\
          f'{os.path.join(path_results, "rh.vonEconomo.label.gii")} ' +\
          f'{os.path.join(path_results, "rh.vonEconomo.border")}'
os.system(command)

# end -------------------------------------------------------------------------

#------------------------------------------------------------------------------
# Needed information to do spin-test
#------------------------------------------------------------------------------

schaefer = fetch_atlas_schaefer_2018(n_rois = nnodes)
nnodes = len(schaefer['labels'])
coords = np.genfromtxt(base_path + 'data/schaefer_400.txt')[:,1:]
hemiid = np.zeros((nnodes, ))
hemiid[:int(nnodes/2)] = 1
spins = gen_spinsamples(coords,
                        hemiid,
                        n_rotate = nspins,
                        seed = 1234,
                        method = 'vasa')

#------------------------------------------------------------------------------
# Von-Economo atlas results
#------------------------------------------------------------------------------

# Get actual/real values
network_specific_disease_measure = np.zeros((num_labels,))
for label_ind in range(num_labels):
    temp = []
    for roi_ind in range(nnodes):
        if atlas_7Network_von[roi_ind] == label_ind:
            temp.append(disease_profile[roi_ind,])
    print(np.array(temp).shape)
    network_specific_disease_measure[label_ind,] = np.nanmean(np.array(temp))

# Get null values
network_specific_disease_measure_nulls = np.zeros((num_labels, nspins))
for spin_ind in range(nspins):
    spinned_disease_measure = disease_profile[spins[:,spin_ind]]
    for label_ind in range(num_labels):
        temp = []
        for roi_ind in range(nnodes):
            if atlas_7Network_von[roi_ind] == label_ind:
                temp.append(spinned_disease_measure[roi_ind])
        network_specific_disease_measure_nulls[label_ind, spin_ind] = np.nanmean(np.array(temp))

# Get non-parametric p-value given the null distributions
p_value_spin = np.zeros((num_labels,))
for label_ind in range(num_labels):
    p_value_spin[label_ind] = pval_cal(network_specific_disease_measure[label_ind],
                                       network_specific_disease_measure_nulls[label_ind,:].flatten(),
                                       nspins)

# Do fdr correction
p_value_spin_fdr = multipletests(p_value_spin, method = 'fdr_bh')[1]

#------------------------------------------------------------------------------
# Show some results
#------------------------------------------------------------------------------

print('----------------------------------------------------------------------')
print('measure value')
print(network_specific_disease_measure)
print('----------------------------------------------------------------------')
print('corrected p vals')
print(p_value_spin_fdr)
print('----------------------------------------------------------------------')
print('uncorrected p vals')
print(p_value_spin)
print('----------------------------------------------------------------------')

#------------------------------------------------------------------------------
# Visualization of the results
#------------------------------------------------------------------------------

bar_width = 0.75
y = np.arange(len(label_von_networks))

fig, ax = plt.subplots(figsize=(5, 2))

for i, height in enumerate(network_specific_disease_measure):
    ax.barh(y[i], height, height = bar_width, color = 'silver', alpha = 1)

ax.set_yticks(y)
ax.set_yticklabels(label_von_networks)
ax.spines['top'].set_visible(False)
ax.spines['right'].set_visible(False)

ax = plt.gca()

# Generate x-axis ticks including the maximum value
x_ticks = np.linspace(-0.05, 0.12, num = 5) # 5 ticks from 0 to x_max

ax.set_xticks(x_ticks)

plt.tight_layout()
plt.savefig(os.path.join(path_fig, 'values_von_economo_' + subtype + '.svg'),
            bbox_inches = 'tight',
            dpi = 300,
            transparent = True)
plt.show()

#------------------------------------------------------------------------------
# END